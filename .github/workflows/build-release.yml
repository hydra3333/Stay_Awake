name: Build Windows (PyInstaller) and attach to Release

on:
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: write  # needed to upload assets to the release

jobs:
  build-windows:
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show ref, commit, and icon presence
        run: |
          echo "GITHUB_REF=$env:GITHUB_REF"
          echo "GITHUB_SHA=$env:GITHUB_SHA"
          git rev-parse HEAD
          $names = 'Stay_Awake_icon.png','Stay_Awake_icon.jpg','Stay_Awake_icon.jpeg','Stay_Awake_icon.webp','Stay_Awake_icon.bmp','Stay_Awake_icon.gif'
          foreach ($n in $names) {          
            $p = Join-Path "${{ github.workspace }}" $n
            if (Test-Path $p) {
                $len = (Get-Item $p).Length
                Write-Host "FOUND: $n ($len bytes)"
            } else {
                Write-Host "missing: $n"
            }
          }

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Print Python info
        run: |
          python -V
          pip -V

      - name: Install dependencies (your preferred flags)
        run: |
          pip install wakepy --no-cache-dir --upgrade --check-build-dependencies --upgrade-strategy eager --verbose
          pip install pystray --no-cache-dir --upgrade --check-build-dependencies --upgrade-strategy eager --verbose
          pip install Pillow --no-cache-dir --upgrade --check-build-dependencies --upgrade-strategy eager --verbose
          pip install pyinstaller --no-cache-dir --upgrade --check-build-dependencies --upgrade-strategy eager --verbose

      - name: Derive version from Release tag (or fallback)
        id: meta
        run: |
          $raw = $env:GITHUB_REF_NAME
          if (-not $raw) {
            try { $raw = (git describe --tags --always) } catch { }
            if (-not $raw) { $raw = (git rev-parse --short HEAD) }
          }
          # Sanitize for filenames: replace invalid chars, collapse whitespace, trim trailing dots
          # Allow only letters, digits, dot, underscore, dash
          $ver = $raw -replace '[^A-Za-z0-9._-]','_'
          # Collapse repeats; trim
          $ver = $ver -replace '[_\.-]{2,}','_'
          $ver = $ver.Trim('_','.')
          $ver = $ver.TrimEnd('.')
          if (-not $ver) { $ver = "build_$($env:GITHUB_RUN_NUMBER)" }
          echo "version=$ver" | Out-File $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host "Tag: $raw  ->  sanitized version: $ver"

      - name: Define names
        id: names
        run: |
          $App = 'Stay_Awake'
          $Ver = '${{ steps.meta.outputs.version }}'
          $OneFileZip = "${App}_${Ver}_windows_onefile.zip"
          $OneDirZip  = "${App}_${Ver}_windows_onedir.zip"
          echo "app=$App" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "onefile_zip=$OneFileZip" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "onedir_zip=$OneDirZip" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Show derived names
        run: |
          Write-Host "onefile_zip:  ${{ steps.names.outputs.onefile_zip }}"
          Write-Host "onedir_zip :  ${{ steps.names.outputs.onedir_zip }}"

      # ---------- ICON from Image for shortcut-to ----------
      - name: Create ICO from Image for shortcut-to
        shell: pwsh
        run: |
          $root  = "${{ github.workspace }}"
          $names = @(
            'Stay_Awake_icon.png','Stay_Awake_icon.jpg','Stay_Awake_icon.jpeg',
            'Stay_Awake_icon.webp','Stay_Awake_icon.bmp','Stay_Awake_icon.gif'
          )
          $sourceImage = $null
          foreach ($n in $names) {
            $p = Join-Path $root $n
            if (Test-Path $p) {
              $sourceImage = (Resolve-Path $p).Path
              Write-Host "Create ICON from Image: Found source image: ${sourceImage}"
              break
            }
          }
          if ($sourceImage) {
            Write-Host "Create ICON: Found $sourceImage"
            # Pass path via env var (no quoting issues)
            $env:SRC_IMAGE = $sourceImage
            # Actual icon creation (pad to square; write multiple sizes)
            $code = @'
            import os
            from PIL import Image, ImageOps
            def pad_to_square_edge_stretch(im: Image.Image) -> Image.Image:
                im = ImageOps.exif_transpose(im).convert("RGBA")
                w, h = im.size
                if w == h:
                    return im
                side = max(w, h)
                lp = (side - w) // 2
                rp = side - w - lp
                tp = (side - h) // 2
                bp = side - h - tp
                sq = Image.new("RGBA", (side, side), (0, 0, 0, 0))
                if tp:
                    strip = im.crop((0, 0, w, 1)).resize((w, tp), Image.NEAREST)
                    sq.paste(strip, (lp, 0))
                if bp:
                    strip = im.crop((0, h-1, w, h)).resize((w, bp), Image.NEAREST)
                    sq.paste(strip, (lp, tp + h))
                if lp:
                    strip = im.crop((0, 0, 1, h)).resize((lp, h), Image.NEAREST)
                    sq.paste(strip, (0, tp))
                if rp:
                    strip = im.crop((w-1, 0, w, h)).resize((rp, h), Image.NEAREST)
                    sq.paste(strip, (lp + w, tp))
                sq.paste(im, (lp, tp), im)
                return sq
            src = os.environ["SRC_IMAGE"]
            out = "Stay_Awake_icon.ico"
            with Image.open(src) as im:
                sq = pad_to_square_edge_stretch(im)
                sq.save(out, sizes=[(16,16),(20,20),(24,24),(32,32),(40,40),(48,48),(64,64),(128,128),(256,256)])
            print("OK:", out)
'@
            #python -c $code
            Set-Content -Path icon_build.py -Value $code -Encoding utf8
            python icon_build.py
          } else {
            Write-Host "Create ICO from Image: No source image found for ICO creation."
          }

      # ---------- ONEFILE ----------
      - name: Clean (onefile)
        run: |
          if (Test-Path .\dist)  { Remove-Item .\dist  -Recurse -Force -ErrorAction SilentlyContinue }
          if (Test-Path .\build) { Remove-Item .\build -Recurse -Force -ErrorAction SilentlyContinue }
          if (Test-Path .\Stay_Awake.spec) { Remove-Item .\Stay_Awake.spec -Force -ErrorAction SilentlyContinue }
          if (Test-Path .\${{ steps.names.outputs.onefile_zip }}) { Remove-Item .\${{ steps.names.outputs.onefile_zip }} -Force -ErrorAction SilentlyContinue }

      - name: PyInstaller (onefile, windowed, no console)
        run: |
          $iconParam = if (Test-Path "Stay_Awake_icon.ico") { "--icon `"Stay_Awake_icon.ico`"" } else { "" }
          pyinstaller --clean --onefile --windowed --noconsole $iconParam --name "${{ steps.names.outputs.app }}" Stay_Awake.py
          Get-ChildItem .\dist\

      - name: Zip onefile exe + optional icons
        run: |
          $exePath = ".\dist\${{ steps.names.outputs.app }}.exe"
          if (!(Test-Path $exePath)) { throw "Missing expected exe: $exePath" }
          $root = "${{ github.workspace }}"
          $names = @('Stay_Awake_icon.png','Stay_Awake_icon.jpg','Stay_Awake_icon.jpeg','Stay_Awake_icon.webp','Stay_Awake_icon.bmp','Stay_Awake_icon.gif','Stay_Awake_icon.ico')
          $icons = @()
          foreach ($n in $names) {
            $p = Join-Path $root $n
            if (Test-Path $p) { $icons += (Resolve-Path $p).Path }
          }
          if ($icons.Count -gt 0) {
            Write-Host "Icons found:"; $icons | ForEach-Object { Write-Host " - $_" }
            $paths = @($exePath) + $icons
          } else {
            Write-Host "No icons found at repo root."
            $paths = @($exePath)
          }
          Compress-Archive -Path $paths -DestinationPath ".\${{ steps.names.outputs.onefile_zip }}" -Force -CompressionLevel Optimal
          #Write-Host "Created $((Resolve-Path .\${{ steps.names.outputs.onefile_zip }}).Path)"
          $zipPath = ".\${{ steps.names.outputs.onefile_zip }}"
          Write-Host "Created $((Resolve-Path $zipPath).Path)"
          
      - name: List contents of onefile zip
        run: |
          $zipPath = ".\${{ steps.names.outputs.onefile_zip }}"
          Write-Host "ZIP: $zipPath"
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $z = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          "{0,12} {1,12}  {2}" -f "Size","CompSize","Name"
          "{0,12} {1,12}  {2}" -f "----","--------","----"
          foreach ($e in $z.Entries) {
            "{0,12:N0} {1,12:N0}  {2}" -f $e.Length, $e.CompressedLength, $e.FullName
          }
          $z.Dispose()
          # Presence checks (non-fatal warnings, or switch to 'throw' if you want hard failures)
          $hasExe   = "${{ steps.names.outputs.app }}.exe"   # <- just a string
          $iconLike = @('Stay_Awake_icon.png','Stay_Awake_icon.jpg','Stay_Awake_icon.jpeg','Stay_Awake_icon.webp','Stay_Awake_icon.bmp','Stay_Awake_icon.gif','Stay_Awake_icon.ico')
          $z = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          $names = $z.Entries | ForEach-Object FullName
          $z.Dispose()
          if ($names -notcontains $hasExe) { Write-Warning "EXE not found in onefile zip." }
          if (-not ($names | Where-Object { $_ -in $iconLike })) { Write-Warning "No icon file found in onefile zip." }

      # ---------- ONEDIR ----------
      - name: PyInstaller (onedir, windowed, no console)
        run: |
          $iconParam = if (Test-Path "Stay_Awake_icon.ico") { "--icon `"Stay_Awake_icon.ico`"" } else { "" }
          pyinstaller --clean --onedir --windowed --noconsole $iconParam --name "${{ steps.names.outputs.app }}" Stay_Awake.py
          Get-ChildItem .\dist\${{ steps.names.outputs.app }}\

      - name: Copy icons into onedir folder (next to the EXE)
        run: |
          $appDir = ".\dist\${{ steps.names.outputs.app }}"
          if (!(Test-Path $appDir)) { throw "Missing app directory: $appDir" }
          $root = "${{ github.workspace }}"
          $names = @('Stay_Awake_icon.png','Stay_Awake_icon.jpg','Stay_Awake_icon.jpeg','Stay_Awake_icon.webp','Stay_Awake_icon.bmp','Stay_Awake_icon.gif','Stay_Awake_icon.ico')
          $icons = @()
          foreach ($n in $names) {
            $p = Join-Path $root $n
            if (Test-Path $p) { $icons += (Resolve-Path $p).Path }
          }
          if ($icons.Count -gt 0) {
            Copy-Item -Path $icons -Destination $appDir -Force
            Write-Host "Copied icons to ${appDir}:"
            $icons | ForEach-Object { Write-Host " - $_" }
          } else {
            Write-Host "No icons found to copy."
          }
          Write-Host "Contents of ${appDir} after copy:"
          Get-ChildItem $appDir | Format-Table -AutoSize

      - name: Zip onedir (contents only, no top-level "dist")
        run: |
          $appDir = ".\dist\${{ steps.names.outputs.app }}"
          if (!(Test-Path $appDir)) { throw "Missing app directory: $appDir" }
          # Put the EXE and (copied) icons at the root of the ZIP (matches your .bat outcome)
          Compress-Archive -Path "$appDir\*" -DestinationPath ".\${{ steps.names.outputs.onedir_zip }}" -Force -CompressionLevel Optimal
          #Write-Host "Created $((Resolve-Path .\${{ steps.names.outputs.onedir_zip }}).Path)"
          $zipPath = ".\${{ steps.names.outputs.onedir_zip }}"
          Write-Host "Created $((Resolve-Path $zipPath).Path)"

      - name: List contents of onedir zip (top-level only)
        run: |
          $zipPath = ".\${{ steps.names.outputs.onedir_zip }}"
          Write-Host "ZIP: $zipPath"
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $z = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          # Top-level files only (entries with no "/" in their FullName)
          $rootFiles = $z.Entries | Where-Object { $_.FullName -notmatch '/' }
          "{0,12} {1,12}  {2}" -f "Size","CompSize","Name"
          "{0,12} {1,12}  {2}" -f "----","--------","----"
          $rootFiles | ForEach-Object {
            "{0,12:N0} {1,12:N0}  {2}" -f $_.Length, $_.CompressedLength, $_.FullName
          }
          # Optional: list top-level directory names (no recursion)
          $rootDirs = $z.Entries |
            Where-Object { $_.FullName -match '^[^/]+/$' } |
            Select-Object -ExpandProperty FullName -Unique
          if ($rootDirs) {
            Write-Host ""
            Write-Host "Top-level directories:"
            $rootDirs | ForEach-Object { Write-Host " - $_" }
          }
          # Presence checks (root-level only is fine because exe & icons are at root)
          $hasExe   = "${{ steps.names.outputs.app }}.exe"
          $iconLike = @('Stay_Awake_icon.png','Stay_Awake_icon.jpg','Stay_Awake_icon.jpeg','Stay_Awake_icon.webp','Stay_Awake_icon.bmp','Stay_Awake_icon.gif','Stay_Awake_icon.ico')
          $names = $rootFiles | ForEach-Object FullName
          $z.Dispose()
          if ($names -notcontains $hasExe) { Write-Warning "EXE not found at zip root." }
          if (-not ($names | Where-Object { $_ -in $iconLike })) { Write-Warning "No icon file found at zip root." }

      # ---------- Upload as workflow artifacts (for debugging / history) ----------
      - name: Upload artifact (onefile zip)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.names.outputs.onefile_zip }}
          path: ${{ steps.names.outputs.onefile_zip }}

      - name: Upload artifact (onedir zip)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.names.outputs.onedir_zip }}
          path: ${{ steps.names.outputs.onedir_zip }}

      # ---------- Attach to the GitHub Release ----------
      - name: Attach assets to the Release
        if: ${{ github.event_name == 'release' && github.event.action == 'published' }}
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.names.outputs.onefile_zip }}
            ${{ steps.names.outputs.onedir_zip }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
